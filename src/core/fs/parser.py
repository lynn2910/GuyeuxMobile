from typing import List, Tuple

from core.fs.tokenizer import Token, TokenType, Tokenizer
from core.graph import RoadGraph
from entities.vehicle import Vehicle
from entities.vehicle_spawner import VehicleSpawner
from models.edges.cellular import CellularEdge
from models.edges.fluid import FluidEdge
from models.intersections.traffic_light_intersection import TrafficLightIntersection


class Parser:
    """
    Parses a stream of tokens from a .map file into structured data.

    This class consumes tokens generated by the Tokenizer and builds up
    data structures representing the graph, vehicles, spawners, and intersections.
    It enforces the syntax of the custom map file format.
    """

    def __init__(self, tokens: List[Token]):
        self.tokens = tokens
        self.pos = 0

    def current_token(self) -> Token:
        """Returns the current token without consuming it."""
        if self.pos >= len(self.tokens):
            # Return the last token (usually EOF) if we are at the end.
            return self.tokens[-1]
        return self.tokens[self.pos]

    def advance(self):
        """Consumes the current token and moves to the next one."""
        self.pos += 1

    def expect(self, token_type: TokenType) -> Token:
        """
        Consumes the current token if it matches the expected type.

        Raises:
            SyntaxError: If the current token does not match the expected type.
        """
        token = self.current_token()
        if token.type != token_type:
            raise SyntaxError(f"Expected {token_type}, found {token.type} ('{token.value}') at line {token.line}")
        self.advance()
        return token

    def skip_newlines(self):
        """Advances past any sequential NEWLINE tokens."""
        while self.current_token().type == TokenType.NEWLINE:
            self.advance()

    def parse_graph(self) -> dict:
        """Parses the GRAPH section of the file."""
        self.skip_newlines()
        self.expect(TokenType.GRAPH)

        # Default graph type is cellular, but can be specified like GRAPH(fluid)
        graph_type = "cellular"
        if self.current_token().type == TokenType.LPAREN:
            self.advance()
            token_val = self.expect(TokenType.IDENTIFIER)
            graph_type = token_val.value
            self.expect(TokenType.RPAREN)

        self.expect(TokenType.COLON)
        self.skip_newlines()

        nodes = {}
        edges = []

        # Loop through all node and edge definitions.
        while self.current_token().type in [TokenType.NODE, TokenType.UEDGE, TokenType.BEDGE]:
            if self.current_token().type == TokenType.NODE:
                node_id, x, y = self.parse_node()
                nodes[node_id] = (x, y)
            elif self.current_token().type in [TokenType.UEDGE, TokenType.BEDGE]:
                edge_type = self.current_token().type
                from_node, to_node, params = self.parse_edge(edge_type)
                edges.append((edge_type, from_node, to_node, params))
            self.skip_newlines()

        return {
            "type": graph_type,
            "nodes": nodes,
            "edges": edges
        }

    def parse_node(self) -> Tuple[str, float, float]:
        """Parses a NODE definition line."""
        self.expect(TokenType.NODE)
        node_id = self.expect(TokenType.IDENTIFIER).value
        self.expect(TokenType.LPAREN)
        x = self.expect(TokenType.NUMBER).value
        self.expect(TokenType.COMMA)
        y = self.expect(TokenType.NUMBER).value
        self.expect(TokenType.RPAREN)
        return node_id, x, y

    def parse_edge(self, edge_type: TokenType) -> Tuple[str, str, dict]:
        """Parses a UEDGE or BEDGE definition line."""
        self.expect(edge_type)
        from_node = self.expect(TokenType.IDENTIFIER).value
        to_node = self.expect(TokenType.IDENTIFIER).value

        # Parse optional key-value parameters for the edge.
        params = {}
        while self.current_token().type == TokenType.IDENTIFIER:
            key = self.expect(TokenType.IDENTIFIER).value
            self.expect(TokenType.EQUALS)
            value = self.expect(TokenType.NUMBER).value
            params[key] = value

        return from_node, to_node, params

    def parse_simulation(self) -> List[dict]:
        """Parses the SIMULATION or VEHICLES section."""
        self.skip_newlines()
        # The caller checks for SIMULATION or VEHICLES, so we just advance past it.
        self.advance()
        self.expect(TokenType.COLON)
        self.skip_newlines()

        cars = []
        while self.current_token().type == TokenType.CAR:
            car_data = self.parse_car()
            cars.append(car_data)
            self.skip_newlines()
        return cars

    def parse_spawners_section(self) -> List[dict]:
        """Parses the SPAWNERS section."""
        self.skip_newlines()
        self.expect(TokenType.SPAWNERS)
        self.expect(TokenType.COLON)
        self.skip_newlines()

        spawners = []
        while self.current_token().type == TokenType.SPAWNER:
            # Format: SPAWNER NodeID ratio=0.5
            self.expect(TokenType.SPAWNER)
            node_id = self.expect(TokenType.IDENTIFIER).value

            params = {}
            while self.current_token().type == TokenType.IDENTIFIER:
                key = self.expect(TokenType.IDENTIFIER).value
                self.expect(TokenType.EQUALS)
                value = self.expect(TokenType.NUMBER).value
                params[key] = value

            spawners.append({"node": node_id, "params": params})
            self.skip_newlines()
        return spawners

    def parse_car(self) -> dict:
        """Parses a CAR definition line."""
        self.expect(TokenType.CAR)
        try:
            car_id = self.expect(TokenType.IDENTIFIER).value
        except SyntaxError:
            car_id = self.expect(TokenType.NUMBER).value

        self.expect(TokenType.LPAREN)
        start_node = self.expect(TokenType.IDENTIFIER).value
        self.expect(TokenType.COMMA)
        end_node = self.expect(TokenType.IDENTIFIER).value
        self.expect(TokenType.RPAREN)

        return {
            "id": car_id,
            "start": start_node,
            "end": end_node
        }

    def parse_intersections(self) -> List[dict]:
        """Parses the INTERSECTIONS section."""
        self.skip_newlines()
        self.expect(TokenType.INTERSECTIONS)
        self.expect(TokenType.COLON)
        self.skip_newlines()

        intersections = []
        # Check the current token to determine the intersection type.
        while self.current_token().type in [TokenType.TRAFFIC_LIGHT]:  # More types can be added here.
            intersection_type = "UNKNOWN"
            node_id = ""
            params = {}

            if self.current_token().type == TokenType.TRAFFIC_LIGHT:
                intersection_type = "TRAFFIC_LIGHT"
                self.expect(TokenType.TRAFFIC_LIGHT)
                node_id = self.expect(TokenType.IDENTIFIER).value

                # Parse specific parameters for traffic lights.
                while self.current_token().type == TokenType.IDENTIFIER:
                    key = self.expect(TokenType.IDENTIFIER).value
                    self.expect(TokenType.EQUALS)
                    value = self.expect(TokenType.NUMBER).value
                    params[key] = value

            intersections.append({
                "type": intersection_type,
                "node": node_id,
                "params": params
            })
            self.skip_newlines()
        return intersections


def import_map(file_path: str):
    """
    Reads a .smap file, tokenizes it, parses it, and builds the simulation objects.

    This is the main entry point for loading a map configuration from a file.
    It orchestrates the tokenizer, parser, and builder functions.

    Returns:
        A tuple containing the RoadGraph, a list of initial vehicles, and a list of spawners.
    """
    with open(file_path, "r") as f:
        content = f.read()

    tokenizer = Tokenizer(content)
    tokens = tokenizer.tokenize()
    parser = Parser(tokens)

    graph_data = None
    simulation_data = []
    spawners_data = []
    intersections_data = []

    parser.skip_newlines()
    # Top-level loop to parse all sections of the file.
    while parser.current_token().type != TokenType.EOF:
        token_type = parser.current_token().type

        if token_type == TokenType.GRAPH:
            if graph_data is not None:
                raise SyntaxError(f"Duplicate GRAPH section at line {parser.current_token().line}")
            graph_data = parser.parse_graph()
        elif token_type in [TokenType.SIMULATION, TokenType.VEHICLES]:
            if simulation_data:
                raise SyntaxError(f"Duplicate VEHICLES/SIMULATION section at line {parser.current_token().line}")
            simulation_data = parser.parse_simulation()
        elif token_type == TokenType.SPAWNERS:
            if spawners_data:
                raise SyntaxError(f"Duplicate SPAWNERS section at line {parser.current_token().line}")
            spawners_data = parser.parse_spawners_section()
        elif token_type == TokenType.INTERSECTIONS:
            if intersections_data:
                raise SyntaxError(f"Duplicate INTERSECTIONS section at line {parser.current_token().line}")
            intersections_data = parser.parse_intersections()
        else:
            token = parser.current_token()
            raise SyntaxError(f"Unexpected token '{token.value}' of type {token.type} at line {token.line}")

        parser.skip_newlines()

    if graph_data is None:
        raise SyntaxError("Missing GRAPH section")

    # Build the final objects from the parsed data.
    graph = build_graph(graph_data)
    build_intersections(intersections_data, graph)
    vehicles = build_vehicles(simulation_data, graph)
    spawners = build_spawners(spawners_data, graph)

    return graph, vehicles, spawners


def build_graph(graph_data: dict) -> RoadGraph:
    """Constructs a RoadGraph object from parsed graph data."""
    graph = RoadGraph()
    graph_type = graph_data["type"]  # "cellular" or "fluid"

    for node_id, (x, y) in graph_data["nodes"].items():
        graph.add_node(node_id, x, y)

    for edge_type, from_node, to_node, params in graph_data["edges"]:
        x1, y1 = graph_data["nodes"][from_node]
        x2, y2 = graph_data["nodes"][to_node]
        default_distance = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5

        distance = float(params.get("distance", default_distance))
        vmax = int(params.get("vmax", 5))
        prob_slow = float(params.get("prob_slow", 0.1))
        density_max = float(params.get("density_max", 0.2))

        edge_obj = None
        edge_obj_back = None

        # Select the appropriate edge model based on the graph type.
        if graph_type == "cellular":
            edge_model = CellularEdge
            model_params = {'distance': int(distance), 'vmax': vmax, 'prob_slow': prob_slow}
        elif graph_type == "fluid":
            edge_model = FluidEdge
            model_params = {'distance': int(distance), 'vmax': vmax, 'density_max': density_max}
        else:
            raise SyntaxError(f"Unknown graph type: {graph_type}")

        if edge_type == TokenType.UEDGE:
            edge_obj = edge_model(**model_params)
        elif edge_type == TokenType.BEDGE:
            edge_obj = edge_model(**model_params)
            edge_obj_back = edge_model(**model_params)

        if edge_obj:
            graph.add_edge(from_node, to_node, edge_obj)
        if edge_obj_back:
            graph.add_edge(to_node, from_node, edge_obj_back)

    return graph


def build_vehicles(simulation_data: List[dict], graph: RoadGraph) -> List[Tuple[Vehicle, any]]:
    """Creates Vehicle objects and determines their initial paths."""
    vehicles = []
    # The pathfinding weight function can be dependent on the edge model.
    path_func = CellularEdge.evaluate_weight

    for car_data in simulation_data:
        start_node = car_data["start"]
        end_node = car_data["end"]

        try:
            vehicle_path = graph.get_path(start_node, end_node, path_func)
        except RuntimeError as e:
            print(f"Warning: {e} for vehicle {car_data['id']}")
            continue

        if not vehicle_path or len(vehicle_path) < 2:
            print(f"Warning: cannot find a path from {start_node} to {end_node} for vehicle {car_data['id']}")
            continue

        # The first node in the path is the start, so the vehicle's travel path starts from the second node.
        vehicle = Vehicle(vehicle_id=car_data["id"], path=vehicle_path[1:])
        start_edge = graph.get_edge(vehicle_path[0], vehicle_path[1])
        vehicles.append((vehicle, start_edge))

    return vehicles


def build_spawners(spawners_data: List[dict], graph: RoadGraph) -> List[VehicleSpawner]:
    """Creates VehicleSpawner objects from parsed spawner data."""
    spawners = []
    for data in spawners_data:
        node_id = data["node"]
        if not graph.graph.has_node(node_id):
            print(f"Warning: Spawner defined on non-existent node '{node_id}'")
            continue

        ratio = float(data["params"].get("ratio", 0.05))
        spawners.append(VehicleSpawner(ratio, node_id))
    return spawners


def build_intersections(data_list: List[dict], graph: RoadGraph):
    """Creates and attaches intersection logic objects to the graph."""
    for item in data_list:
        node_id = item["node"]
        itype = item["type"]
        params = item["params"]

        incoming = graph.get_incoming_nodes(node_id)
        intersection_obj = None

        if itype == "TRAFFIC_LIGHT":
            duration = int(params.get("duration", 50))
            intersection_obj = TrafficLightIntersection(node_id, incoming, duration)
        # Example for future extension:
        # elif itype == "STOP_SIGN":
        #     intersection_obj = StopIntersection(node_id, incoming)

        if intersection_obj:
            graph.add_intersection(intersection_obj)
